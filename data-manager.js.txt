// =============================================================================
// DOUK√à Compta Pro - Gestionnaire de donn√©es avec isolation v3.1
// =============================================================================

class DataManager {
    constructor(securityManager) {
        this.security = securityManager;
        this.companyDataCache = new Map();
        this.dataValidators = new Map();
        this.changeListeners = new Map();
        
        this.setupValidators();
        console.log('üíæ DataManager avec isolation initialis√©');
    }

    // Configuration des validateurs de donn√©es
    setupValidators() {
        this.dataValidators.set('user', this.validateUser.bind(this));
        this.dataValidators.set('company', this.validateCompany.bind(this));
        this.dataValidators.set('entry', this.validateEntry.bind(this));
        this.dataValidators.set('cashRegister', this.validateCashRegister.bind(this));
        this.dataValidators.set('account', this.validateAccount.bind(this));
    }

    // Obtenir toutes les donn√©es d'une entreprise avec v√©rification d'acc√®s
    getCompanyData(companyId, userId = null) {
        const currentUserId = userId || (window.app.currentUser ? window.app.currentUser.id : null);

        if (!this.security.hasAccessToCompany(currentUserId, companyId)) {
            throw new SecurityError(`üö´ Acc√®s refus√© √† l'entreprise ${companyId}`);
        }

        // V√©rifier le cache
        const cacheKey = `${companyId}_${currentUserId}`;
        if (this.companyDataCache.has(cacheKey)) {
            const cached = this.companyDataCache.get(cacheKey);
            if (Date.now() - cached.timestamp < 300000) { // Cache valide 5 minutes
                return cached.data;
            }
        }

        // R√©cup√©rer les donn√©es
        const data = {
            accounts: this.getCompanyAccounts(companyId, userId),
            entries: this.getCompanyEntries(companyId, userId),
            cashRegisters: this.getCompanyCashRegisters(companyId, userId),
            users: this.getCompanyUsers(companyId, userId),
            metadata: {
                companyId,
                accessLevel: this.getAccessLevel(currentUserId),
                lastUpdate: new Date().toISOString()
            }
        };

        // Mettre en cache
        this.companyDataCache.set(cacheKey, {
            data,
            timestamp: Date.now()
        });

        return data;
    }

    // Obtenir les √©critures d'une entreprise
    getCompanyEntries(companyId, userId = null) {
        const currentUserId = userId || (window.app.currentUser ? window.app.currentUser.id : null);
        
        if (!this.security.hasAccessToCompany(currentUserId, companyId)) {
            throw new SecurityError(`üö´ Acc√®s refus√© aux √©critures de l'entreprise ${companyId}`);
        }

        const entries = window.app.entries.filter(entry => entry.companyId === companyId);
        
        // Filtrage suppl√©mentaire selon le profil
        const user = this.security.getCurrentUser(currentUserId);
        if (user && user.profile === 'caissier') {
            // Les caissiers ne voient que les √©critures de caisse
            return entries.filter(entry => 
                entry.journal === 'JC' || 
                (entry.userId === currentUserId)
            );
        }

        return entries;
    }

    // Obtenir les comptes d'une entreprise
    getCompanyAccounts(companyId, userId = null) {
        const currentUserId = userId || (window.app.currentUser ? window.app.currentUser.id : null);
        
        if (!this.security.hasAccessToCompany(currentUserId, companyId)) {
            throw new SecurityError(`üö´ Acc√®s refus√© au plan comptable de l'entreprise ${companyId}`);
        }

        // Le plan comptable SYSCOHADA est global mais peut √™tre filtr√© par entreprise
        return window.app.accounts.filter(account => {
            // Logique de filtrage si n√©cessaire (comptes sp√©cifiques √† l'entreprise)
            return true; // Pour l'instant, tous les comptes SYSCOHADA sont disponibles
        });
    }

    // Obtenir les caisses d'une entreprise
    getCompanyCashRegisters(companyId, userId = null) {
        const currentUserId = userId || (window.app.currentUser ? window.app.currentUser.id : null);
        
        if (!this.security.hasAccessToCompany(currentUserId, companyId)) {
            throw new SecurityError(`üö´ Acc√®s refus√© aux caisses de l'entreprise ${companyId}`);
        }

        const cashRegisters = window.app.cashRegisters.filter(cash => cash.companyId === companyId);
        
        // Filtrage selon le profil
        const user = this.security.getCurrentUser(currentUserId);
        if (user && user.profile === 'caissier') {
            // Les caissiers ne voient que leurs caisses
            return cashRegisters.filter(cash => cash.responsibleId === currentUserId);
        }

        return cashRegisters;
    }

    // Obtenir les utilisateurs d'une entreprise
    getCompanyUsers(companyId, userId = null) {
        const currentUserId = userId || (window.app.currentUser ? window.app.currentUser.id : null);
        
        if (!this.security.hasAccessToCompany(currentUserId, companyId)) {
            throw new SecurityError(`üö´ Acc√®s refus√© aux utilisateurs de l'entreprise ${companyId}`);
        }

        return window.app.users.filter(user =>
            user.companyId === companyId ||
            (user.assignedCompanies && user.assignedCompanies.includes(companyId))
        );
    }

    // Cr√©er une nouvelle entr√©e avec validation
    createEntry(entryData, companyId) {
        // V√©rifications de s√©curit√©
        if (!this.security.hasAccessToCompany(window.app.currentUser.id, companyId)) {
            throw new SecurityError('Acc√®s refus√© pour cr√©er une √©criture dans cette entreprise');
        }

        // Validation des donn√©es
        this.validateEntry(entryData);

        // G√©n√©rer un ID unique
        const newId = Math.max(...window.app.entries.map(e => e.id), 0) + 1;

        const entry = {
            id: newId,
            ...entryData,
            companyId: companyId,
            userId: window.app.currentUser.id,
            status: 'En attente',
            createdAt: new Date().toISOString(),
            modifiedAt: new Date().toISOString()
        };

        // Ajouter √† la base de donn√©es
        window.app.entries.push(entry);

        // Invalider le cache
        this.invalidateCompanyCache(companyId);

        // Notifier les listeners
        this.notifyChange('entry', 'create', entry);

        // Log de s√©curit√©
        this.security.logSecurityEvent('entry_created', {
            entryId: newId,
            companyId,
            journal: entry.journal
        });

        return entry;
    }

    // Mettre √† jour une entr√©e
    updateEntry(entryId, updateData) {
        const entry = window.app.entries.find(e => e.id === entryId);
        if (!entry) {
            throw new Error('√âcriture non trouv√©e');
        }

        // V√©rifications de s√©curit√©
        if (!this.security.hasAccessToCompany(window.app.currentUser.id, entry.companyId)) {
            throw new SecurityError('Acc√®s refus√© pour modifier cette √©criture');
        }

        // Validation des donn√©es
        this.validateEntry({ ...entry, ...updateData });

        // Mise √† jour
        Object.assign(entry, updateData, {
            modifiedAt: new Date().toISOString(),
            modifiedBy: window.app.currentUser.id
        });

        // Invalider le cache
        this.invalidateCompanyCache(entry.companyId);

        // Notifier les listeners
        this.notifyChange('entry', 'update', entry);

        // Log de s√©curit√©
        this.security.logSecurityEvent('entry_updated', {
            entryId,
            companyId: entry.companyId
        });

        return entry;
    }

    // Supprimer une entr√©e
    deleteEntry(entryId) {
        const entryIndex = window.app.entries.findIndex(e => e.id === entryId);
        if (entryIndex === -1) {
            throw new Error('√âcriture non trouv√©e');
        }

        const entry = window.app.entries[entryIndex];

        // V√©rifications de s√©curit√©
        if (!this.security.hasAccessToCompany(window.app.currentUser.id, entry.companyId)) {
            throw new SecurityError('Acc√®s refus√© pour supprimer cette √©criture');
        }

        if (entry.status === 'Valid√©' && window.app.currentUser.profile !== 'admin') {
            throw new Error('Impossible de supprimer une √©criture valid√©e');
        }

        // Supprimer
        window.app.entries.splice(entryIndex, 1);

        // Invalider le cache
        this.invalidateCompanyCache(entry.companyId);

        // Notifier les listeners
        this.notifyChange('entry', 'delete', { id: entryId, companyId: entry.companyId });

        // Log de s√©curit√©
        this.security.logSecurityEvent('entry_deleted', {
            entryId,
            companyId: entry.companyId
        });

        return true;
    }

    // Invalidation du cache
    invalidateCompanyCache(companyId) {
        for (const [key] of this.companyDataCache) {
            if (key.startsWith(`${companyId}_`)) {
                this.companyDataCache.delete(key);
            }
        }
    }

    // Obtenir le niveau d'acc√®s d'un utilisateur
    getAccessLevel(userId) {
        const user = this.security.getCurrentUser(userId);
        if (!user) return 0;
        return this.security.profileHierarchy[user.profile] || 0;
    }

    // Validation des donn√©es
    validateUser(userData) {
        const required = ['name', 'email', 'profile'];
        const missing = required.filter(field => !userData[field]);
        if (missing.length > 0) {
            throw new Error(`Champs obligatoires manquants: ${missing.join(', ')}`);
        }

        if (!this.isValidEmail(userData.email)) {
            throw new Error('Email invalide');
        }

        if (!this.security.profileHierarchy[userData.profile]) {
            throw new Error('Profil invalide');
        }

        return true;
    }

    validateCompany(companyData) {
        const required = ['name', 'type', 'status'];
        const missing = required.filter(field => !companyData[field]);
        if (missing.length > 0) {
            throw new Error(`Champs obligatoires manquants: ${missing.join(', ')}`);
        }

        const validTypes = ['SARL', 'SA', 'EURL', 'SAS', 'SNC', 'SCI'];
        if (!validTypes.includes(companyData.type)) {
            throw new Error('Type d\'entreprise invalide');
        }

        return true;
    }

    validateEntry(entryData) {
        const required = ['date', 'journal', 'libelle', 'lines'];
        const missing = required.filter(field => !entryData[field]);
        if (missing.length > 0) {
            throw new Error(`Champs obligatoires manquants: ${missing.join(', ')}`);
        }

        if (!entryData.lines || !Array.isArray(entryData.lines) || entryData.lines.length < 2) {
            throw new Error('Une √©criture doit avoir au moins 2 lignes');
        }

        // V√©rifier l'√©quilibre
        const totalDebit = entryData.lines.reduce((sum, line) => sum + (line.debit || 0), 0);
        const totalCredit = entryData.lines.reduce((sum, line) => sum + (line.credit || 0), 0);

        if (Math.abs(totalDebit - totalCredit) > 0.01) {
            throw new Error('L\'√©criture doit √™tre √©quilibr√©e (Total D√©bit = Total Cr√©dit)');
        }

        return true;
    }

    validateCashRegister(cashData) {
        const required = ['name', 'companyId'];
        const missing = required.filter(field => !cashData[field]);
        if (missing.length > 0) {
            throw new Error(`Champs obligatoires manquants: ${missing.join(', ')}`);
        }

        if (cashData.maxLimit && cashData.maxLimit < 0) {
            throw new Error('La limite maximale ne peut pas √™tre n√©gative');
        }

        return true;
    }

    validateAccount(accountData) {
        const required = ['code', 'name', 'category', 'type', 'nature'];
        const missing = required.filter(field => !accountData[field]);
        if (missing.length > 0) {
            throw new Error(`Champs obligatoires manquants: ${missing.join(', ')}`);
        }

        if (!/^\d{6}$/.test(accountData.code)) {
            throw new Error('Le code compte doit contenir exactement 6 chiffres');
        }

        return true;
    }

    // Utilitaires
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    // Syst√®me de listeners pour les changements de donn√©es
    addChangeListener(type, callback) {
        if (!this.changeListeners.has(type)) {
            this.changeListeners.set(type, []);
        }
        this.changeListeners.get(type).push(callback);
    }

    removeChangeListener(type, callback) {
        if (this.changeListeners.has(type)) {
            const listeners = this.changeListeners.get(type);
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    notifyChange(type, action, data) {
        if (this.changeListeners.has(type)) {
            this.changeListeners.get(type).forEach(callback => {
                try {
                    callback({ type, action, data });
                } catch (error) {
                    console.error('Erreur dans le listener de changement:', error);
                }
            });
        }
    }

    // Obtenir les statistiques de donn√©es
    getDataStatistics(companyId = null) {
        if (companyId) {
            const data = this.getCompanyData(companyId);
            return {
                entries: data.entries.length,
                accounts: data.accounts.length,
                cashRegisters: data.cashRegisters.length,
                users: data.users.length,
                companyId
            };
        }

        return {
            totalEntries: window.app.entries.length,
            totalAccounts: window.app.accounts.length,
            totalCashRegisters: window.app.cashRegisters.length,
            totalUsers: window.app.users.length,
            totalCompanies: window.app.companies.length
        };
    }

    // Nettoyage du cache
    clearCache() {
        this.companyDataCache.clear();
        console.log('üíæ Cache des donn√©es nettoy√©');
    }

    // Sauvegarde des donn√©es (simulation)
    async saveData() {
        try {
            // Dans un environnement r√©el, ceci sauvegarderait dans une base de donn√©es
            localStorage.setItem('doukeComptaData', JSON.stringify({
                accounts: window.app.accounts,
                companies: window.app.companies,
                users: window.app.users,
                entries: window.app.entries,
                cashRegisters: window.app.cashRegisters,
                lastSave: new Date().toISOString()
            }));

            this.security.logSecurityEvent('data_saved');
            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            throw error;
        }
    }

    // Chargement des donn√©es (simulation)
    async loadData() {
        try {
            const savedData = localStorage.getItem('doukeComptaData');
            if (savedData) {
                const data = JSON.parse(savedData);
                
                window.app.accounts = data.accounts || [];
                window.app.companies = data.companies || [];
                window.app.users = data.users || [];
                window.app.entries = data.entries || [];
                window.app.cashRegisters = data.cashRegisters || [];

                this.clearCache();
                this.security.logSecurityEvent('data_loaded');
                return true;
            }
            return false;
        } catch (error) {
            console.error('Erreur lors du chargement:', error);
            throw error;
        }
    }
}

// Export de la classe
window.DataManager = DataManager;

console.log('üì¶ Module DataManager charg√©');